{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AggregatorInterface} from \"./AggregatorInterface.sol\";\nimport {AggregatorV3Interface} from \"./AggregatorV3Interface.sol\";\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../shared/interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface {\n  uint256 public constant override version = 0;\n\n  uint8 public override decimals;\n  int256 public override latestAnswer;\n  uint256 public override latestTimestamp;\n  uint256 public override latestRound;\n\n  mapping(uint256 => int256) public override getAnswer;\n  mapping(uint256 => uint256) public override getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(uint8 _decimals, int256 _initialAnswer) {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(int256 _answer) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description() external pure override returns (string memory) {\n    return \"v0.8/tests/MockV3Aggregator.sol\";\n  }\n}\n"
    },
    "contracts/FundMe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n// 引入chainlink的预言机合约，用于获取链下汇率数据\r\n// 如果引入预言机合约，就不能在本地部署测试了，需要把部署到测试网络中，才能够使用预言机\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\n\r\n// 众筹合约要实现哪些功能？\r\n// 1. 创建一个收款函数\r\n// 2. 记录投资人并且查看\r\n// 3. 在锁定期内，达到目标值，生产商可以提款\r\n// 4. 在锁定期内，没有达到目标值，投资人在锁定期以后退款\r\n\r\ncontract FundMe {\r\n\r\n    mapping(address => uint256) public fundersToAmount;\r\n\r\n    // 引入AggregatorV3Interface预言机合约对象。在solidity中，一个合约就可以作为一个类型\r\n    // 用internal修饰，表明只有当前合约内部的函数才能调用这个变量\r\n    AggregatorV3Interface internal dataFeed;\r\n\r\n    // 设置最小投资金额，solidity中10**18表示10的18次方，1*10^18 wei = 1 ETH\r\n    uint256 constant MINIMUM_VALUE = 1 * 10 ** 18;  // 设置为最少投资1usd\r\n\r\n    // 设置众筹合约的目标值\r\n    // constant修饰后就会变成常量，该值就无法被修改了。常量一般用大写字母命名\r\n    uint256 constant TARGET = 1000 * 10 ** 18;\r\n\r\n    // 合约所有者\r\n    address public owner;\r\n\r\n    // 合约部署时间戳\r\n    uint256 deploymentTimestamp;\r\n    // 锁定期时长\r\n    uint256 lockTime;\r\n\r\n    address erc20Addr;\r\n\r\n    // 标记生产商是否已经完成提款\r\n    bool public getFundSuccess = false;\r\n\r\n    // 智能合约的构造函数\r\n    // 第一个参数是锁定期时长，第二个参数是预言机合约地址\r\n    // 如果我们部署到sepolia测试网络，那么这里就直接传入真实的chainlink预言机提供的sepolia合约地址\r\n    // 如果我们是自己本地部署测试，就传入我们在本地部署的mock合约地址\r\n    constructor(uint256 _lockTime, address dateFeedAddr) {\r\n        // 在构造函数中初始化喂价对象\r\n        // 我们这里采用sepolia testnet（sepolia测试网络），所以在初始化的时候要传入chainlink中提供的sepolia测试网络地址（在sepolia测试网络中部署的预言机地址），这样才能调用到部署在测试网络上的预言机\r\n        // 我们要把合约部署到什么网络上，下面这个初始化就要传入对应网络的预言机部署地址\r\n        dataFeed = AggregatorV3Interface(dateFeedAddr);\r\n\r\n        // 在合约部署的时候会调用构造函数，然后就可以初始化合约所有者为当时部署合约的地址\r\n        owner = msg.sender;\r\n\r\n        // msg系统变量表示的是当前这次交易\r\n        // block系统变量表示的是当前的区块\r\n        // block.timestamp表示当前区块的时间戳是多少\r\n        // 记录合约部署的时间\r\n        deploymentTimestamp = block.timestamp;\r\n        lockTime = _lockTime;\r\n    }\r\n\r\n\r\n    // 收款函数\r\n    // external可以被外部调用，但是不能在合约内部被调用\r\n    // 如果该函数想要收取原生通证，比如如果我们在以太坊上部署智能合约，以太坊的原生通证就是ETH以太币，那么我们想要收取以太币的话就需要在该函数上加上payable关键字\r\n    function fund() external payable {\r\n        \r\n        // require(condition, \"\") 当condition是false时，就会回退本次交易（revert），并提出相应的错误信息\r\n        // 只有当condition是true时，才会成功执行本次交易\r\n        require(convertEthToUsd(msg.value) >= MINIMUM_VALUE, \"Send more ETH\");\r\n        // 获取当前发起这次交易的区块的时间戳，确保当前时间还在锁定期内\r\n        require(block.timestamp < deploymentTimestamp + lockTime, \"window is close\");\r\n\r\n        // 记录下投资人的地址以及他投资了多少金额\r\n        fundersToAmount[msg.sender] = msg.value;\r\n    }\r\n\r\n\r\n    // 该函数返回 1ETH等于多少USD的价格\r\n    // 该函数是AggregatorV3Interface预言机合约提供的\r\n    function getChainlinkDataFeedLatestAnswer() public view returns (int) {\r\n        // prettier-ignore\r\n        (\r\n            /* uint80 roundID */,\r\n            int answer,\r\n            /*uint startedAt*/,\r\n            /*uint timeStamp*/,\r\n            /*uint80 answeredInRound*/\r\n        ) = dataFeed.latestRoundData();\r\n        return answer;\r\n    }\r\n\r\n    // 入参单位是wei，转换未usd\r\n    function convertEthToUsd(uint256 ethAmount) internal view returns (uint256) {\r\n        // 获取1ETH能兑换多少usd\r\n        uint256 ethPrice = uint256(getChainlinkDataFeedLatestAnswer());\r\n        // 将eth换算为usd\r\n        // (ETH amount) * (ETH price) = (ETH value)\r\n        // 我们传入的ethAmount单位是wei，但是预言机返回的换算并不是按照wei换算的，所以相乘的结果还要除以10^8\r\n        return ethAmount * ethPrice / (10 ** 8);\r\n\r\n    }\r\n\r\n    // 转移合约所有权\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        // 只能是合约所有者才能去转移合约所有权\r\n        owner = newOwner;\r\n    }\r\n\r\n    // 在锁定期内，达到目标值，生产商可以提款\r\n    // external修饰表明是一个外部函数，可以被外部调用\r\n    // onlyOwner修改器修饰， 只有合约所有者才能提款\r\n    function getFund() external windowClose onlyOwner {\r\n        // this表示当前合约，address(this)能获取到当前合约的地址，进而就能获取到当前合约已经收取了多少钱\r\n        require(convertEthToUsd(address(this).balance) /*balance的单位是wei*/ >= TARGET, \"Target is not reached\");\r\n\r\n        // solidity中转账操作提供了三个函数，transfer、send和call，其中前两个就是单纯的转账，\r\n        // 第三个call是在实现转行的同时，还能调用指定的函数，来提供更多额外的操作，只要是专场场景都可以用call实现，所以solidity官方推荐用call。当然可能一些老的项目里还会用transfer和send。\r\n        // 1、transfer: transfer ETH and revert if tx failed   如果交易失败，就会回滚本次交易，付款方和收款方的余额都不会有变化\r\n        // 将合约地址上的余额转移到msg.sender，注意这里因为涉及到转账，所以需要把msg.sender转换成payable\r\n        // payable(msg.sender).transfer(address(this).balance);\r\n\r\n        // 2、send: transfer ETH and return false if failed\r\n        // send与transfer的区别就是send会返回一个bool变量，表示该交易是否成功\r\n        // bool success = payable(msg.sender).send(address(this).balance);\r\n        // require(success, \"tx failed\");\r\n\r\n        // 3、call: transfer ETH with data return value of function and bool   它在转账的同时，还可以去调用一些payable函数\r\n        bool success;\r\n        (success, ) = payable(msg.sender).call{value: address(this).balance}(\"\"); // 这里我们并没有调用额外的函数，所以只会返回交易是否成功的bool类型变量\r\n        require(success, \"transfer tx failed\");\r\n        \r\n        // 转移所有钱之后，需要把fundersToAmount数组中所有用户的值都清零\r\n\r\n        // 标记生产商已经完成提款\r\n        getFundSuccess = true;\r\n    }\r\n\r\n    // 在锁定期内，没有达到目标值，投资人在锁定期以后退款\r\n    // 应用windowClose修改器\r\n    function refund() external windowClose {\r\n        require(convertEthToUsd(address(this).balance) < TARGET, \"Target is reached\");\r\n        // 检查一下当前调用合约的这个人之前是否有过众筹投款记录\r\n        require(fundersToAmount[msg.sender] != 0, \"there is no fund for you\");\r\n\r\n        bool success;\r\n        // 把当时该用户投的钱退款\r\n        (success, ) = payable(msg.sender).call{value: fundersToAmount[msg.sender]}(\"\"); // 这里我们并没有调用额外的函数，所以只会返回交易是否成功的bool类型变量\r\n        require(success, \"transfer tx failed\");\r\n        // 清空该用户的fund金额，防止重复退款bug\r\n        fundersToAmount[msg.sender] = 0;\r\n    }\r\n\r\n    // 修改用户投资余额\r\n    function setFunderToAmount(address funder, uint256 amountToUpdate) external {\r\n        // 只有外部erc20合约地址才能调用该函数来修改用户投资余额\r\n        require(msg.sender == erc20Addr, \"you do not have permission to call this funtion\");\r\n        fundersToAmount[funder] = amountToUpdate;\r\n    }\r\n\r\n    // 设置外部erc20合约地址\r\n    // 只有当前合约拥有者才能调用该函数\r\n    function setErc20Addr(address _erc20Addr) public onlyOwner {\r\n        erc20Addr = _erc20Addr;\r\n    }\r\n\r\n    // 定义一个修改器\r\n    // 这里使用修改器来简化代码\r\n    // 有点类似于spring中的AOP切面\r\n    modifier windowClose() {\r\n        require(block.timestamp >= deploymentTimestamp + lockTime, \"window is not close\");\r\n        // 表示应用该修改器的函数的逻辑。这样写相当于在应用该修改器最开始执行上面的require，然后再去执行自己的代码\r\n        _;\r\n    }\r\n\r\n    // 定义一个修改器\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"this function can only be called by owner\");\r\n        // 表示应用该修改器的函数的逻辑。这样写相当于在应用该修改器最开始执行上面的require，然后再去执行自己的代码\r\n        _;\r\n    }\r\n}"
    },
    "contracts/mocks/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n// 使用chainlink的mock合约\r\n// mock合约用于在本地测试环境中模拟链上合约的行为（这个合约仅仅是保证本地测测试是代码能正常运行，但并不保证返回数据的准确性）\r\n// 因为有一些我们需要引入的链上合约比如一些预言机，这些都是部署在链上的，我们在本地部署的合约无法去调用这些合约\r\n// 为了我们在本地部署测试的时候方便，我们可以使用mock合约来模拟这些链上合约的行为\r\n// 通过在本地引入对应合约的mock合约，我们就可以在本地测试环境中使用mock合约来模拟链上合约的行为\r\nimport \"@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol\";\r\n\r\n// 在solidity引入了mock合约后，还需要使用hardhat框架在js中本地部署该mock合约，这样我们才能真正使用它"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}